# v0.13.0 Release Plan — Paper Citation Network (Phase 5a)

> **Version**: 0.13.0
> **Base**: v0.12.1
> **Difficulty**: High
> **Estimated Commits**: 3-4
> **Prerequisite**: v0.12.1 completed

---

## Objective

Add a **Paper Citation Network** view (Litmaps-style scatter plot) that visualizes inter-paper citation relationships. Users click "Build Citation Network" to fetch citation data from Semantic Scholar on demand, and the result is cached in-memory (not persisted to DB).

This is the foundation for v0.13.1 (Concept Citation Flow).

---

## Key Architecture Decision (Review Feedback)

| Decision | Rationale |
|----------|-----------|
| **No DB persistence** | Avoids migration complexity; citation data is ephemeral and can be rebuilt |
| **In-memory cache (TTL 1h)** | Fast re-reads without re-fetching; server restart clears cache acceptably |
| **On-demand async job** | User explicitly triggers build; no background polling or import-pipeline coupling |
| **Import pipeline separation** | Zotero/PDF import does NOT auto-fetch citations; keeps import fast and predictable |

---

## Scope

- `POST /api/graph/citation/{project_id}/build` — async job that fetches references from Semantic Scholar
- `GET /api/graph/citation/{project_id}/network` — returns cached citation graph
- `GET /api/graph/citation/{project_id}/status` — build job status
- New `CitationView.tsx` — D3.js Litmaps-style scatter (X=year, Y=citation count, edges=references)
- 5th tab "Citations" in KnowledgeGraph3D

---

## Reused Code

| Source | What | Location |
|--------|------|----------|
| `SemanticScholarClient.get_references()` | Fetch papers a paper references | `semantic_scholar.py:463` |
| `SemanticScholarClient.get_paper()` | Fetch single paper by ID/DOI | `semantic_scholar.py:349` |
| `SemanticScholarClient._rate_limit()` | Built-in rate limiter | `semantic_scholar.py:195` |
| `paper_metadata` table | DOIs and Semantic Scholar IDs for project papers | DB schema |
| `ViewMode` type | Extend with `'citations'` | `types/graph.ts:331` |
| Background job pattern | Existing import job polling pattern | `frontend/app/projects/[id]/page.tsx` |

---

## Changed Files

| File | Change |
|------|--------|
| `backend/graph/citation_builder.py` | **New** — citation data fetcher + in-memory cache |
| `backend/routers/graph.py` | 3 new endpoints: build, network, status |
| `frontend/components/graph/CitationView.tsx` | **New** — D3.js scatter plot |
| `frontend/components/graph/KnowledgeGraph3D.tsx` | 5th view tab "Citations" |
| `frontend/lib/api.ts` | 3 new API methods |
| `frontend/types/graph.ts` | Extend `ViewMode` |

---

## Implementation Detail

### Backend: Citation Builder

#### `backend/graph/citation_builder.py` — New module

```python
"""
Citation Builder — On-demand citation network construction.

Fetches inter-paper citation data from Semantic Scholar and caches
the result in-memory. No DB persistence (by design decision).

Architecture:
  User clicks "Build" → POST /build → async job → fetches references
  → stores in _cache dict → GET /network returns cached result
"""

import asyncio
import logging
import time
from dataclasses import dataclass, field
from typing import Optional

logger = logging.getLogger(__name__)


@dataclass
class CitationNode:
    """A paper in the citation network."""
    paper_id: str  # Semantic Scholar ID
    local_id: Optional[str] = None  # Our entities table UUID
    title: str = ""
    year: Optional[int] = None
    citation_count: int = 0
    doi: Optional[str] = None
    is_local: bool = False  # True if paper is in our project


@dataclass
class CitationEdge:
    """A citation relationship between two papers."""
    source_id: str  # citing paper
    target_id: str  # cited paper


@dataclass
class CitationNetwork:
    """Complete citation network for a project."""
    nodes: list[CitationNode] = field(default_factory=list)
    edges: list[CitationEdge] = field(default_factory=list)
    papers_matched: int = 0
    papers_total: int = 0
    build_time_seconds: float = 0.0
    built_at: float = 0.0  # timestamp


@dataclass
class BuildStatus:
    """Status of a citation build job."""
    state: str = "idle"  # idle, building, completed, failed
    progress: int = 0  # papers processed
    total: int = 0  # total papers
    error: Optional[str] = None
    started_at: float = 0.0


# In-memory cache: project_id -> CitationNetwork
_cache: dict[str, CitationNetwork] = {}
_cache_ttl = 3600  # 1 hour

# Build job status: project_id -> BuildStatus
_build_status: dict[str, BuildStatus] = {}

# Lock to prevent concurrent builds for same project
_build_locks: dict[str, asyncio.Lock] = {}


def get_cached_network(project_id: str) -> Optional[CitationNetwork]:
    """Get cached citation network if still valid."""
    network = _cache.get(project_id)
    if network and (time.time() - network.built_at) < _cache_ttl:
        return network
    if network:
        del _cache[project_id]  # Expired
    return None


def get_build_status(project_id: str) -> BuildStatus:
    """Get current build status for a project."""
    return _build_status.get(project_id, BuildStatus())


async def build_citation_network(
    project_id: str,
    papers: list[dict],  # [{doi, title, semantic_scholar_id, local_id, year}]
) -> CitationNetwork:
    """
    Build citation network by fetching references from Semantic Scholar.

    Args:
        project_id: Project UUID string
        papers: List of paper dicts with DOI/S2 IDs from our DB

    Returns:
        CitationNetwork with nodes and edges
    """
    from integrations.semantic_scholar import SemanticScholarClient

    # Get or create lock for this project
    if project_id not in _build_locks:
        _build_locks[project_id] = asyncio.Lock()

    async with _build_locks[project_id]:
        status = BuildStatus(
            state="building",
            total=len(papers),
            started_at=time.time(),
        )
        _build_status[project_id] = status

        start_time = time.time()
        nodes: dict[str, CitationNode] = {}
        edges: list[CitationEdge] = []
        matched = 0

        try:
            async with SemanticScholarClient() as client:
                # Phase 1: Resolve our papers to Semantic Scholar IDs
                for paper in papers:
                    doi = paper.get("doi")
                    s2_id = paper.get("semantic_scholar_id")
                    local_id = paper.get("local_id")
                    title = paper.get("title", "")
                    year = paper.get("year")

                    # Try to find paper on S2
                    s2_paper = None
                    if s2_id:
                        s2_paper = await client.get_paper(s2_id)
                    elif doi:
                        s2_paper = await client.get_paper(f"DOI:{doi}")

                    if s2_paper:
                        matched += 1
                        node = CitationNode(
                            paper_id=s2_paper.paper_id,
                            local_id=local_id,
                            title=s2_paper.title or title,
                            year=s2_paper.year or year,
                            citation_count=s2_paper.citation_count,
                            doi=s2_paper.doi or doi,
                            is_local=True,
                        )
                        nodes[s2_paper.paper_id] = node

                    status.progress += 1

                # Phase 2: Fetch references for matched papers
                local_s2_ids = set(nodes.keys())
                for s2_id in list(local_s2_ids):
                    try:
                        refs = await client.get_references(
                            s2_id, limit=50
                        )
                        for ref in refs:
                            # Add reference as node if not already present
                            if ref.paper_id not in nodes:
                                nodes[ref.paper_id] = CitationNode(
                                    paper_id=ref.paper_id,
                                    title=ref.title,
                                    year=ref.year,
                                    citation_count=ref.citation_count,
                                    doi=ref.doi,
                                    is_local=False,
                                )
                            # Add edge: our paper -> referenced paper
                            edges.append(CitationEdge(
                                source_id=s2_id,
                                target_id=ref.paper_id,
                            ))

                            # Check if reference is also one of our papers
                            if ref.paper_id in local_s2_ids:
                                # Internal citation! Keep the edge.
                                pass

                    except Exception as e:
                        logger.warning(f"Failed to get references for {s2_id}: {e}")

            # Build network
            build_time = time.time() - start_time
            network = CitationNetwork(
                nodes=list(nodes.values()),
                edges=edges,
                papers_matched=matched,
                papers_total=len(papers),
                build_time_seconds=round(build_time, 1),
                built_at=time.time(),
            )

            # Cache result
            _cache[project_id] = network

            status.state = "completed"
            status.progress = len(papers)
            logger.info(
                f"Citation network built: {matched}/{len(papers)} papers matched, "
                f"{len(nodes)} nodes, {len(edges)} edges in {build_time:.1f}s"
            )

            return network

        except Exception as e:
            status.state = "failed"
            status.error = str(e)
            logger.error(f"Citation network build failed: {e}")
            raise
```

### Backend: API Endpoints

#### `graph.py` — 3 new endpoints

Insert after the temporal endpoints section:

```python
# ============================================
# Paper Citation Network (Phase 5a: On-Demand)
# ============================================

class CitationNodeResponse(BaseModel):
    paper_id: str
    local_id: Optional[str] = None
    title: str
    year: Optional[int] = None
    citation_count: int = 0
    doi: Optional[str] = None
    is_local: bool = False


class CitationEdgeResponse(BaseModel):
    source_id: str
    target_id: str


class CitationNetworkResponse(BaseModel):
    nodes: List[CitationNodeResponse]
    edges: List[CitationEdgeResponse]
    papers_matched: int
    papers_total: int
    build_time_seconds: float


class CitationBuildStatusResponse(BaseModel):
    state: str  # idle, building, completed, failed
    progress: int
    total: int
    error: Optional[str] = None


@router.post("/citation/{project_id}/build")
async def build_citation_network(
    project_id: UUID,
    background_tasks: BackgroundTasks,
    database=Depends(get_db),
    current_user: Optional[User] = Depends(require_auth_if_configured),
):
    """Start building citation network from Semantic Scholar.

    This is an async job — poll /status to check progress.
    Results are cached in-memory (TTL 1 hour).
    """
    await verify_project_access(database, project_id, current_user, "access")

    from graph.citation_builder import get_build_status, build_citation_network as do_build

    # Check if already building
    status = get_build_status(str(project_id))
    if status.state == "building":
        return {"message": "Build already in progress", "state": "building"}

    # Get papers with DOIs from this project
    paper_rows = await database.fetch(
        """
        SELECT pm.id, pm.title, pm.doi, pm.publication_year,
               pm.properties->>'semantic_scholar_id' as s2_id
        FROM paper_metadata pm
        WHERE pm.project_id = $1
        AND (pm.doi IS NOT NULL OR pm.properties->>'semantic_scholar_id' IS NOT NULL)
        """,
        project_id,
    )

    if not paper_rows:
        raise HTTPException(
            404,
            "No papers with DOIs found. Import papers with DOI metadata first."
        )

    papers = [
        {
            "local_id": str(row["id"]),
            "title": row["title"],
            "doi": row["doi"],
            "semantic_scholar_id": row.get("s2_id"),
            "year": row["publication_year"],
        }
        for row in paper_rows
    ]

    # Start async build
    background_tasks.add_task(do_build, str(project_id), papers)

    return {
        "message": f"Building citation network for {len(papers)} papers",
        "state": "building",
        "total_papers": len(papers),
    }


@router.get("/citation/{project_id}/status", response_model=CitationBuildStatusResponse)
async def get_citation_build_status(
    project_id: UUID,
    current_user: Optional[User] = Depends(require_auth_if_configured),
):
    """Get citation network build status."""
    from graph.citation_builder import get_build_status

    status = get_build_status(str(project_id))
    return CitationBuildStatusResponse(
        state=status.state,
        progress=status.progress,
        total=status.total,
        error=status.error,
    )


@router.get("/citation/{project_id}/network", response_model=CitationNetworkResponse)
async def get_citation_network(
    project_id: UUID,
    database=Depends(get_db),
    current_user: Optional[User] = Depends(require_auth_if_configured),
):
    """Get cached citation network.

    Returns 404 if network hasn't been built yet.
    """
    await verify_project_access(database, project_id, current_user, "access")

    from graph.citation_builder import get_cached_network

    network = get_cached_network(str(project_id))
    if not network:
        raise HTTPException(
            404,
            "Citation network not built. Click 'Build Citation Network' first."
        )

    return CitationNetworkResponse(
        nodes=[
            CitationNodeResponse(
                paper_id=n.paper_id,
                local_id=n.local_id,
                title=n.title,
                year=n.year,
                citation_count=n.citation_count,
                doi=n.doi,
                is_local=n.is_local,
            )
            for n in network.nodes
        ],
        edges=[
            CitationEdgeResponse(
                source_id=e.source_id,
                target_id=e.target_id,
            )
            for e in network.edges
        ],
        papers_matched=network.papers_matched,
        papers_total=network.papers_total,
        build_time_seconds=network.build_time_seconds,
    )
```

> **Note**: Add `from fastapi import BackgroundTasks` to the imports at the top of `graph.py`.

### Frontend: Citation View

#### `CitationView.tsx` — New component (Litmaps-style scatter)

```tsx
'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import { Loader2, GitBranch, AlertCircle, Play } from 'lucide-react';
import * as d3 from 'd3';
import { api } from '@/lib/api';

interface CitationNode {
  paper_id: string;
  local_id: string | null;
  title: string;
  year: number | null;
  citation_count: number;
  doi: string | null;
  is_local: boolean;
}

interface CitationEdge {
  source_id: string;
  target_id: string;
}

interface CitationViewProps {
  projectId: string;
}

export function CitationView({ projectId }: CitationViewProps) {
  const svgRef = useRef<SVGSVGElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [nodes, setNodes] = useState<CitationNode[]>([]);
  const [edges, setEdges] = useState<CitationEdge[]>([]);
  const [loading, setLoading] = useState(false);
  const [building, setBuilding] = useState(false);
  const [buildProgress, setBuildProgress] = useState({ progress: 0, total: 0 });
  const [error, setError] = useState<string | null>(null);
  const [stats, setStats] = useState<{ matched: number; total: number } | null>(null);
  const [hoveredNode, setHoveredNode] = useState<CitationNode | null>(null);

  // Try to load cached network on mount
  useEffect(() => {
    setLoading(true);
    api.getCitationNetwork(projectId)
      .then(result => {
        setNodes(result.nodes);
        setEdges(result.edges);
        setStats({ matched: result.papers_matched, total: result.papers_total });
      })
      .catch(() => {
        // No cached network — show build button
      })
      .finally(() => setLoading(false));
  }, [projectId]);

  // Build citation network
  const handleBuild = useCallback(async () => {
    setBuilding(true);
    setError(null);
    try {
      await api.buildCitationNetwork(projectId);

      // Poll status
      const poll = async () => {
        const status = await api.getCitationBuildStatus(projectId);
        setBuildProgress({ progress: status.progress, total: status.total });

        if (status.state === 'completed') {
          // Fetch the built network
          const result = await api.getCitationNetwork(projectId);
          setNodes(result.nodes);
          setEdges(result.edges);
          setStats({ matched: result.papers_matched, total: result.papers_total });
          setBuilding(false);
        } else if (status.state === 'failed') {
          setError(status.error || 'Build failed');
          setBuilding(false);
        } else {
          setTimeout(poll, 2000); // Poll every 2s
        }
      };
      setTimeout(poll, 1000); // Start polling after 1s

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to start build');
      setBuilding(false);
    }
  }, [projectId]);

  // D3 scatter plot rendering
  useEffect(() => {
    if (!nodes.length || !svgRef.current || !containerRef.current) return;

    const container = containerRef.current;
    const width = container.clientWidth;
    const height = container.clientHeight - 20;
    const margin = { top: 30, right: 30, bottom: 50, left: 70 };
    const innerW = width - margin.left - margin.right;
    const innerH = height - margin.top - margin.bottom;

    const svg = d3.select(svgRef.current);
    svg.selectAll('*').remove();
    svg.attr('width', width).attr('height', height);

    const g = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

    // Filter nodes with year data for scatter
    const plotNodes = nodes.filter(n => n.year != null);

    // Scales
    const yearExtent = d3.extent(plotNodes, n => n.year!) as [number, number];
    const x = d3.scaleLinear()
      .domain([yearExtent[0] - 1, yearExtent[1] + 1])
      .range([0, innerW]);

    const maxCitations = d3.max(plotNodes, n => n.citation_count) || 1;
    const y = d3.scaleLog()
      .domain([1, maxCitations + 1])
      .range([innerH, 0])
      .clamp(true);

    // Axes
    g.append('g')
      .attr('transform', `translate(0,${innerH})`)
      .call(d3.axisBottom(x).tickFormat(d3.format('d')))
      .selectAll('text').style('fill', 'currentColor');

    g.append('g')
      .call(d3.axisLeft(y).ticks(5, '~s'))
      .selectAll('text').style('fill', 'currentColor');

    // Axis labels
    g.append('text')
      .attr('x', innerW / 2).attr('y', innerH + 40)
      .attr('text-anchor', 'middle')
      .style('fill', 'currentColor').style('font-size', '12px')
      .text('Publication Year');

    g.append('text')
      .attr('transform', 'rotate(-90)')
      .attr('y', -55).attr('x', -innerH / 2)
      .attr('text-anchor', 'middle')
      .style('fill', 'currentColor').style('font-size', '12px')
      .text('Citations (log)');

    // Build node lookup for edges
    const nodeMap = new Map(plotNodes.map(n => [n.paper_id, n]));

    // Draw edges (behind nodes)
    g.selectAll('.citation-edge')
      .data(edges.filter(e => nodeMap.has(e.source_id) && nodeMap.has(e.target_id)))
      .join('line')
      .attr('class', 'citation-edge')
      .attr('x1', d => x(nodeMap.get(d.source_id)!.year!))
      .attr('y1', d => y(Math.max(1, nodeMap.get(d.source_id)!.citation_count)))
      .attr('x2', d => x(nodeMap.get(d.target_id)!.year!))
      .attr('y2', d => y(Math.max(1, nodeMap.get(d.target_id)!.citation_count)))
      .attr('stroke', '#457B9D')
      .attr('stroke-opacity', 0.15)
      .attr('stroke-width', 0.5);

    // Draw nodes
    g.selectAll('.paper-node')
      .data(plotNodes)
      .join('circle')
      .attr('class', 'paper-node')
      .attr('cx', d => x(d.year!))
      .attr('cy', d => y(Math.max(1, d.citation_count)))
      .attr('r', d => d.is_local ? 6 : 3)
      .attr('fill', d => d.is_local ? '#2EC4B6' : '#457B9D')
      .attr('opacity', d => d.is_local ? 0.9 : 0.4)
      .attr('stroke', d => d.is_local ? '#fff' : 'none')
      .attr('stroke-width', d => d.is_local ? 1.5 : 0)
      .style('cursor', 'pointer')
      .on('mouseenter', function(event, d) {
        d3.select(this).attr('r', d.is_local ? 9 : 5).attr('opacity', 1);
        setHoveredNode(d);
      })
      .on('mouseleave', function(event, d) {
        d3.select(this).attr('r', d.is_local ? 6 : 3).attr('opacity', d.is_local ? 0.9 : 0.4);
        setHoveredNode(null);
      })
      .on('click', (event, d) => {
        if (d.doi) {
          window.open(`https://doi.org/${d.doi}`, '_blank');
        }
      });

  }, [nodes, edges]);

  // Empty state: no network built
  if (!loading && !building && !nodes.length) {
    return (
      <div className="w-full h-full flex flex-col items-center justify-center gap-4">
        <GitBranch className="w-12 h-12 text-muted" />
        <p className="font-mono text-xs text-muted uppercase tracking-wider">
          Paper Citation Network
        </p>
        <p className="text-sm text-muted text-center max-w-md">
          Build a citation network to see how your papers reference each other
          and discover influential works in the citation graph.
        </p>
        <button
          onClick={handleBuild}
          disabled={building}
          className="px-6 py-3 bg-accent-teal/10 hover:bg-accent-teal/20
            text-accent-teal font-mono text-sm uppercase tracking-wider
            border border-accent-teal/30 transition-colors
            flex items-center gap-2"
        >
          <Play className="w-4 h-4" />
          Build Citation Network
        </button>
        {error && (
          <p className="text-xs text-accent-red">{error}</p>
        )}
      </div>
    );
  }

  // Building state
  if (building) {
    return (
      <div className="w-full h-full flex flex-col items-center justify-center gap-4">
        <Loader2 className="w-8 h-8 animate-spin text-accent-teal" />
        <p className="font-mono text-xs text-accent-teal uppercase tracking-wider">
          Building Citation Network...
        </p>
        <p className="text-sm text-muted">
          {buildProgress.progress} / {buildProgress.total} papers processed
        </p>
        <div className="w-64 h-2 bg-surface/20 rounded-full overflow-hidden">
          <div
            className="h-full bg-accent-teal transition-all duration-500"
            style={{
              width: buildProgress.total
                ? `${(buildProgress.progress / buildProgress.total) * 100}%`
                : '0%'
            }}
          />
        </div>
      </div>
    );
  }

  // Loading cached network
  if (loading) {
    return (
      <div className="w-full h-full flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-accent-teal" />
      </div>
    );
  }

  return (
    <div ref={containerRef} className="w-full h-full relative">
      {/* Stats bar */}
      <div className="absolute top-2 left-4 z-10 flex items-center gap-4">
        {stats && (
          <>
            <span className="font-mono text-xs text-accent-teal">
              {stats.matched} of {stats.total} papers matched
            </span>
            <span className="font-mono text-xs text-muted">
              {nodes.length} nodes · {edges.length} edges
            </span>
          </>
        )}
        <button
          onClick={handleBuild}
          className="font-mono text-xs text-muted hover:text-accent-teal transition-colors"
          title="Rebuild citation network"
        >
          Rebuild
        </button>
      </div>

      {/* Legend */}
      <div className="absolute top-2 right-4 z-10 flex items-center gap-4">
        <div className="flex items-center gap-1">
          <div className="w-3 h-3 rounded-full bg-[#2EC4B6] border border-white" />
          <span className="font-mono text-xs text-muted">Your papers</span>
        </div>
        <div className="flex items-center gap-1">
          <div className="w-2 h-2 rounded-full bg-[#457B9D]" />
          <span className="font-mono text-xs text-muted">Referenced papers</span>
        </div>
      </div>

      {/* Tooltip */}
      {hoveredNode && (
        <div className="absolute bottom-16 left-1/2 -translate-x-1/2 z-20
          bg-paper dark:bg-ink border border-ink/10 dark:border-paper/10
          p-3 shadow-lg font-mono text-xs max-w-sm">
          <p className="text-ink dark:text-paper font-bold mb-1 line-clamp-2">
            {hoveredNode.title}
          </p>
          <div className="flex items-center gap-3 text-muted">
            {hoveredNode.year && <span>{hoveredNode.year}</span>}
            <span>{hoveredNode.citation_count} citations</span>
            {hoveredNode.is_local && (
              <span className="text-accent-teal">In your project</span>
            )}
          </div>
          {hoveredNode.doi && (
            <p className="text-accent-teal mt-1">Click to open DOI</p>
          )}
        </div>
      )}

      {/* D3 Chart */}
      <svg ref={svgRef} className="w-full h-full" />
    </div>
  );
}
```

### Frontend: Integration

#### `types/graph.ts` — Extend ViewMode

```typescript
// Change:
export type ViewMode = '3d' | 'topic' | 'gaps' | 'temporal';
// To:
export type ViewMode = '3d' | 'topic' | 'gaps' | 'temporal' | 'citations';
```

#### `KnowledgeGraph3D.tsx` — 5th tab

Add import:
```typescript
import { CitationView } from './CitationView';
```

Add view rendering:
```tsx
{viewMode === 'citations' && (
  <CitationView projectId={projectId} />
)}
```

Add tab button (after Temporal tab):
```tsx
<button
  onClick={() => setViewMode('citations')}
  className={`flex items-center gap-1.5 px-3 py-1.5 rounded text-sm font-medium transition-all ${
    viewMode === 'citations'
      ? 'bg-[#457B9D] text-white shadow-sm'
      : 'text-muted hover:text-ink dark:hover:text-paper hover:bg-surface/10'
  }`}
  title="논문 인용 네트워크 (Citations)"
>
  <GitBranch className="w-4 h-4" />
  Citations
</button>
```

> **Note**: Add `GitBranch` to lucide-react imports.

#### `api.ts` — 3 new methods

Add after `getTemporalTimeline()`:

```typescript
// Citation Network
async buildCitationNetwork(projectId: string): Promise<{
  message: string;
  state: string;
  total_papers: number;
}> {
  return this.request(`/api/graph/citation/${projectId}/build`, {
    method: 'POST',
  });
}

async getCitationBuildStatus(projectId: string): Promise<{
  state: string;
  progress: number;
  total: number;
  error: string | null;
}> {
  return this.request(`/api/graph/citation/${projectId}/status`);
}

async getCitationNetwork(projectId: string): Promise<{
  nodes: Array<{
    paper_id: string;
    local_id: string | null;
    title: string;
    year: number | null;
    citation_count: number;
    doi: string | null;
    is_local: boolean;
  }>;
  edges: Array<{ source_id: string; target_id: string }>;
  papers_matched: number;
  papers_total: number;
  build_time_seconds: number;
}> {
  return this.request(`/api/graph/citation/${projectId}/network`);
}
```

---

## Commit Strategy

| Order | Message | Files |
|-------|---------|-------|
| 1 | `feat(citation): on-demand citation builder with in-memory cache` | `citation_builder.py` |
| 2 | `feat(citation): citation network API endpoints (build/status/network)` | `graph.py` |
| 3 | `feat(citation): Litmaps-style scatter plot citation view` | `CitationView.tsx`, `KnowledgeGraph3D.tsx`, `api.ts`, `types/graph.ts` |
| 4 | `docs(v0.13.0): release notes and SDD updates` | `RELEASE_NOTES_v0.13.0.md`, `DOCS/` |

---

## Acceptance Criteria

| # | Criterion | Verification |
|---|-----------|-------------|
| 1 | **Response time**: Build job starts < 1 second; completes in < 2 minutes for 34 papers | `time` the build; poll `/status` |
| 2 | **Fallback**: Papers without DOI are skipped; "X of Y papers matched" shown in UI | Import papers without DOIs; verify count |
| 3 | **UI**: Citations tab → Litmaps-style scatter with local papers (teal, large) and referenced papers (blue, small); hover shows title/year/citations | Visual check in browser |

---

## Technical Risks & Mitigations

| Risk | Probability | Mitigation |
|------|-------------|-----------|
| Semantic Scholar API quota exhaustion | High | Rate limiter built into client; sequential requests; limit=50 refs per paper |
| Most papers lack DOI in Zotero export | Medium | Show "X of Y matched"; title-based search as future enhancement |
| In-memory cache lost on server restart | Low | Acceptable for demo; user re-builds in <2 min; DB persistence deferred to v0.13.1 |
| Render free tier memory with large networks | Medium | 34 papers × 50 refs = ~1700 nodes max; well within 512MB |
| Build job runs during import | Low | Separate concerns; citation build is user-initiated only |
| D3 log scale with 0 citations | Low | Use `Math.max(1, citation_count)` and `y.clamp(true)` |

---

## Architecture: Why No DB Persistence

This was a deliberate decision from the review:

1. **Complexity**: Adding `CITES` relationships to the `relationships` table would require a migration and pollute the concept graph
2. **Cache semantics**: Citation data is external and changes over time — treating it as ephemeral is more honest
3. **Performance**: In-memory dict lookup is O(1) vs DB query
4. **Reversibility**: If v0.13.1 needs DB persistence, the `CitationNetwork` dataclass maps cleanly to a table

The decision on whether to persist will be revisited in v0.13.1 based on real usage patterns.
