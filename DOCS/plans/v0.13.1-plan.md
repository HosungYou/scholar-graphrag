# v0.13.1 Release Plan — Concept Citation Flow (Phase 5b)

> **Version**: 0.13.1
> **Base**: v0.13.0
> **Difficulty**: High
> **Estimated Commits**: 2-3
> **Prerequisite**: v0.13.0 (Paper Citation Network) completed

---

## Objective

Visualize **knowledge propagation through citations** at the concept level — a feature unique to ScholaRAG Graph that no existing tool offers.

While v0.13.0 shows *which papers cite which papers*, v0.13.1 answers: **"Which concepts influenced which concepts through citations?"**

### Portfolio Differentiator

> "Existing tools like Litmaps and Connected Papers show paper-level citation networks.
> ScholaRAG Graph goes further: it traces how **concepts flow through citation chains** —
> revealing which ideas influenced which research directions."

---

## Conceptual Model

```
Paper A discusses [AI Trust], [Algorithmic Fairness]
Paper B cites Paper A and discusses [AI Ethics], [Algorithmic Fairness]

Concept flow:
  [AI Trust] ──citation──→ [AI Ethics]
  [Algorithmic Fairness] ──citation──→ [Algorithmic Fairness] (reinforcement)

Aggregated across all citations:
  Concept X ──(N citations)──→ Concept Y
  (where N = number of citing paper pairs connecting these concepts)
```

The flow is computed by:
1. Taking the paper citation graph from v0.13.0 (cached in-memory)
2. Looking up which concepts each paper discusses (from `relationships` table: `DISCUSSES_CONCEPT`)
3. Creating concept-to-concept flow edges weighted by citation count

---

## Scope

- `GET /api/graph/citation/{project_id}/concept-flow` — compute concept flow from cached citation data
- New `ConceptFlowView.tsx` — Sankey or force-directed concept flow visualization
- 6th tab "Flow" in KnowledgeGraph3D (or sub-view within Citations tab)
- **DB persistence decision**: Deferred — use in-memory computation from cached citation network

---

## Reused Code

| Source | What | Location |
|--------|------|----------|
| `citation_builder.get_cached_network()` | Cached paper citation graph from v0.13.0 | `citation_builder.py` |
| `relationships` table | `DISCUSSES_CONCEPT` edges linking papers to concepts | DB |
| `entities` table | Concept names and properties | DB |
| `CitationNode.local_id` | Maps S2 papers back to our `paper_metadata` | `citation_builder.py` |

---

## Changed Files

| File | Change |
|------|--------|
| `backend/graph/citation_builder.py` | Add `compute_concept_flow()` function |
| `backend/routers/graph.py` | Add `GET /api/graph/citation/{project_id}/concept-flow` endpoint |
| `frontend/components/graph/ConceptFlowView.tsx` | **New** — Sankey/force-directed flow visualization |
| `frontend/components/graph/KnowledgeGraph3D.tsx` | Add "Flow" sub-tab or 6th tab |
| `frontend/lib/api.ts` | Add `getConceptFlow()` method |
| `frontend/types/graph.ts` | Extend `ViewMode` if adding 6th tab |

---

## Implementation Detail

### Backend: Concept Flow Computation

#### `citation_builder.py` — Add `compute_concept_flow()`

```python
@dataclass
class ConceptFlowEdge:
    """A concept-to-concept flow through citations."""
    source_concept_id: str
    source_concept_name: str
    target_concept_id: str
    target_concept_name: str
    weight: int  # Number of citation pairs supporting this flow
    example_papers: list[str] = field(default_factory=list)  # Paper titles


@dataclass
class ConceptFlowNetwork:
    """Concept-level citation flow."""
    nodes: list[dict]  # [{id, name, paper_count, is_source, is_target}]
    edges: list[ConceptFlowEdge]
    total_flows: int
    unique_concepts: int


async def compute_concept_flow(
    project_id: str,
    database,
    min_weight: int = 1,
    max_concepts: int = 50,
) -> Optional[ConceptFlowNetwork]:
    """
    Compute concept-to-concept knowledge flow from citation network.

    Algorithm:
    1. Get cached citation network (paper-level)
    2. For each citation edge (paper_A cites paper_B):
       a. Get concepts discussed by paper_A (via DISCUSSES_CONCEPT)
       b. Get concepts discussed by paper_B (via DISCUSSES_CONCEPT)
       c. Create flow edges: each concept in B → each concept in A
          (knowledge flows from cited to citing paper)
    3. Aggregate by concept pairs, weight = citation count
    4. Return top flows by weight

    Returns None if citation network not built.
    """
    network = get_cached_network(project_id)
    if not network:
        return None

    # Build paper_id (S2) -> local_id mapping
    s2_to_local = {}
    for node in network.nodes:
        if node.is_local and node.local_id:
            s2_to_local[node.paper_id] = node.local_id

    if not s2_to_local:
        return None

    # Get paper -> concepts mapping from DB
    # Only for our local papers (not external referenced papers)
    local_ids = list(s2_to_local.values())
    concept_rows = await database.fetch(
        """
        SELECT r.source_id as paper_id, r.target_id as concept_id, e.name as concept_name
        FROM relationships r
        JOIN entities e ON e.id = r.target_id
        WHERE r.project_id = $1
          AND r.relationship_type IN ('DISCUSSES_CONCEPT', 'USES_METHOD', 'SUPPORTS')
          AND r.source_id = ANY($2::uuid[])
        """,
        project_id,
        local_ids,
    )

    # Build paper_local_id -> set of (concept_id, concept_name)
    paper_concepts: dict[str, set[tuple[str, str]]] = {}
    for row in concept_rows:
        pid = str(row["paper_id"])
        cid = str(row["concept_id"])
        cname = row["concept_name"]
        if pid not in paper_concepts:
            paper_concepts[pid] = set()
        paper_concepts[pid].add((cid, cname))

    # Build local_id -> S2_id reverse mapping
    local_to_s2 = {v: k for k, v in s2_to_local.items()}

    # Compute concept flows from citation edges
    # Flow direction: cited paper's concepts → citing paper's concepts
    flow_counts: dict[tuple[str, str], int] = {}  # (source_concept, target_concept) -> count
    concept_names: dict[str, str] = {}  # concept_id -> name
    flow_examples: dict[tuple[str, str], list[str]] = {}  # paper titles

    for edge in network.edges:
        # edge.source_id = citing paper (S2 ID)
        # edge.target_id = cited paper (S2 ID)
        citing_local = s2_to_local.get(edge.source_id)
        cited_local = s2_to_local.get(edge.target_id)

        if not citing_local or not cited_local:
            continue  # Skip if either paper is external

        citing_concepts = paper_concepts.get(citing_local, set())
        cited_concepts = paper_concepts.get(cited_local, set())

        if not citing_concepts or not cited_concepts:
            continue

        # Flow: cited concepts → citing concepts (knowledge propagation)
        for cited_cid, cited_name in cited_concepts:
            for citing_cid, citing_name in citing_concepts:
                if cited_cid == citing_cid:
                    continue  # Skip self-loops (same concept reinforcement)

                key = (cited_cid, citing_cid)
                flow_counts[key] = flow_counts.get(key, 0) + 1
                concept_names[cited_cid] = cited_name
                concept_names[citing_cid] = citing_name

                # Track example paper titles
                if key not in flow_examples:
                    flow_examples[key] = []
                citing_node = next(
                    (n for n in network.nodes if n.paper_id == edge.source_id), None
                )
                if citing_node and len(flow_examples[key]) < 3:
                    flow_examples[key].append(citing_node.title)

    # Filter by minimum weight and sort
    flow_edges = []
    for (src_id, tgt_id), weight in sorted(
        flow_counts.items(), key=lambda x: x[1], reverse=True
    ):
        if weight < min_weight:
            continue
        flow_edges.append(ConceptFlowEdge(
            source_concept_id=src_id,
            source_concept_name=concept_names[src_id],
            target_concept_id=tgt_id,
            target_concept_name=concept_names[tgt_id],
            weight=weight,
            example_papers=flow_examples.get((src_id, tgt_id), []),
        ))

    # Limit to top concepts
    top_concept_ids = set()
    for edge in flow_edges[:max_concepts * 2]:  # Take enough edges
        top_concept_ids.add(edge.source_concept_id)
        top_concept_ids.add(edge.target_concept_id)
        if len(top_concept_ids) >= max_concepts:
            break

    # Filter edges to only include top concepts
    filtered_edges = [
        e for e in flow_edges
        if e.source_concept_id in top_concept_ids
        and e.target_concept_id in top_concept_ids
    ]

    # Build node list
    source_ids = {e.source_concept_id for e in filtered_edges}
    target_ids = {e.target_concept_id for e in filtered_edges}
    all_concept_ids = source_ids | target_ids

    nodes = []
    for cid in all_concept_ids:
        paper_count = sum(
            1 for pid, concepts in paper_concepts.items()
            if any(c[0] == cid for c in concepts)
        )
        nodes.append({
            "id": cid,
            "name": concept_names.get(cid, "Unknown"),
            "paper_count": paper_count,
            "is_source": cid in source_ids,
            "is_target": cid in target_ids,
        })

    return ConceptFlowNetwork(
        nodes=nodes,
        edges=filtered_edges,
        total_flows=len(filtered_edges),
        unique_concepts=len(all_concept_ids),
    )
```

### Backend: API Endpoint

#### `graph.py` — Concept flow endpoint

```python
class ConceptFlowEdgeResponse(BaseModel):
    source_concept_id: str
    source_concept_name: str
    target_concept_id: str
    target_concept_name: str
    weight: int
    example_papers: List[str]


class ConceptFlowResponse(BaseModel):
    nodes: List[dict]
    edges: List[ConceptFlowEdgeResponse]
    total_flows: int
    unique_concepts: int


@router.get("/citation/{project_id}/concept-flow", response_model=ConceptFlowResponse)
async def get_concept_citation_flow(
    project_id: UUID,
    min_weight: int = Query(1, ge=1, le=10),
    max_concepts: int = Query(30, ge=10, le=100),
    database=Depends(get_db),
    current_user: Optional[User] = Depends(require_auth_if_configured),
):
    """Get concept-level knowledge flow derived from paper citations.

    Requires citation network to be built first (POST /citation/{id}/build).
    """
    await verify_project_access(database, project_id, current_user, "access")

    from graph.citation_builder import compute_concept_flow

    flow = await compute_concept_flow(
        str(project_id), database,
        min_weight=min_weight,
        max_concepts=max_concepts,
    )

    if flow is None:
        raise HTTPException(
            404,
            "Citation network not built. Build the citation network first."
        )

    return ConceptFlowResponse(
        nodes=flow.nodes,
        edges=[
            ConceptFlowEdgeResponse(
                source_concept_id=e.source_concept_id,
                source_concept_name=e.source_concept_name,
                target_concept_id=e.target_concept_id,
                target_concept_name=e.target_concept_name,
                weight=e.weight,
                example_papers=e.example_papers,
            )
            for e in flow.edges
        ],
        total_flows=flow.total_flows,
        unique_concepts=flow.unique_concepts,
    )
```

### Frontend: Concept Flow Visualization

#### `ConceptFlowView.tsx` — Force-directed flow diagram

The visualization uses a D3 force-directed layout where:
- **Nodes** = concepts (sized by paper count)
- **Edges** = knowledge flow (width proportional to citation weight, with arrows)
- **Color** = source concepts (teal) vs target concepts (amber) vs both (purple)

```tsx
'use client';

import { useEffect, useRef, useState } from 'react';
import { Loader2, Workflow, AlertCircle } from 'lucide-react';
import * as d3 from 'd3';
import { api } from '@/lib/api';

interface FlowNode {
  id: string;
  name: string;
  paper_count: number;
  is_source: boolean;
  is_target: boolean;
  // D3 simulation properties
  x?: number;
  y?: number;
  vx?: number;
  vy?: number;
}

interface FlowEdge {
  source_concept_id: string;
  source_concept_name: string;
  target_concept_id: string;
  target_concept_name: string;
  weight: number;
  example_papers: string[];
}

interface ConceptFlowViewProps {
  projectId: string;
}

export function ConceptFlowView({ projectId }: ConceptFlowViewProps) {
  const svgRef = useRef<SVGSVGElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [nodes, setNodes] = useState<FlowNode[]>([]);
  const [edges, setEdges] = useState<FlowEdge[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [stats, setStats] = useState<{ flows: number; concepts: number } | null>(null);
  const [hoveredEdge, setHoveredEdge] = useState<FlowEdge | null>(null);

  // Fetch concept flow data
  useEffect(() => {
    let cancelled = false;
    setLoading(true);
    setError(null);

    api.getConceptFlow(projectId)
      .then(result => {
        if (!cancelled) {
          setNodes(result.nodes as FlowNode[]);
          setEdges(result.edges);
          setStats({ flows: result.total_flows, concepts: result.unique_concepts });
        }
      })
      .catch(err => {
        if (!cancelled) {
          setError(err.message || 'Failed to load concept flow');
        }
      })
      .finally(() => {
        if (!cancelled) setLoading(false);
      });

    return () => { cancelled = true; };
  }, [projectId]);

  // D3 force-directed rendering
  useEffect(() => {
    if (!nodes.length || !edges.length || !svgRef.current || !containerRef.current) return;

    const container = containerRef.current;
    const width = container.clientWidth;
    const height = container.clientHeight;

    const svg = d3.select(svgRef.current);
    svg.selectAll('*').remove();
    svg.attr('width', width).attr('height', height);

    // Arrow marker definition
    svg.append('defs').append('marker')
      .attr('id', 'arrowhead')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 20)
      .attr('refY', 0)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#457B9D');

    const g = svg.append('g');

    // Zoom
    const zoom = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.3, 3])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
      });
    svg.call(zoom);

    // Node size scale
    const maxPapers = d3.max(nodes, n => n.paper_count) || 1;
    const sizeScale = d3.scaleSqrt().domain([0, maxPapers]).range([8, 24]);

    // Edge width scale
    const maxWeight = d3.max(edges, e => e.weight) || 1;
    const widthScale = d3.scaleLinear().domain([1, maxWeight]).range([1, 6]);

    // Color: source=teal, target=amber, both=purple
    const nodeColor = (d: FlowNode) => {
      if (d.is_source && d.is_target) return '#9D4EDD';  // Both
      if (d.is_source) return '#2EC4B6';  // Source (knowledge origin)
      return '#F4A261';  // Target (knowledge destination)
    };

    // Build D3 link data
    const links = edges.map(e => ({
      source: e.source_concept_id,
      target: e.target_concept_id,
      weight: e.weight,
      data: e,
    }));

    // Force simulation
    const simulation = d3.forceSimulation(nodes as d3.SimulationNodeDatum[])
      .force('link', d3.forceLink(links)
        .id((d: any) => d.id)
        .distance(100)
        .strength(0.3))
      .force('charge', d3.forceManyBody().strength(-200))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius((d: any) => sizeScale(d.paper_count) + 5));

    // Draw edges
    const linkElements = g.selectAll('.flow-link')
      .data(links)
      .join('line')
      .attr('class', 'flow-link')
      .attr('stroke', '#457B9D')
      .attr('stroke-opacity', 0.4)
      .attr('stroke-width', d => widthScale(d.weight))
      .attr('marker-end', 'url(#arrowhead)')
      .style('cursor', 'pointer')
      .on('mouseenter', function(event, d) {
        d3.select(this).attr('stroke-opacity', 0.9).attr('stroke', '#2EC4B6');
        setHoveredEdge(d.data);
      })
      .on('mouseleave', function() {
        d3.select(this).attr('stroke-opacity', 0.4).attr('stroke', '#457B9D');
        setHoveredEdge(null);
      });

    // Draw nodes
    const nodeElements = g.selectAll('.flow-node')
      .data(nodes)
      .join('g')
      .attr('class', 'flow-node')
      .style('cursor', 'grab')
      .call(d3.drag<SVGGElement, FlowNode>()
        .on('start', (event, d: any) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x; d.fy = d.y;
        })
        .on('drag', (event, d: any) => {
          d.fx = event.x; d.fy = event.y;
        })
        .on('end', (event, d: any) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null; d.fy = null;
        })
      );

    nodeElements.append('circle')
      .attr('r', d => sizeScale(d.paper_count))
      .attr('fill', d => nodeColor(d))
      .attr('opacity', 0.85)
      .attr('stroke', '#fff')
      .attr('stroke-width', 1.5);

    nodeElements.append('text')
      .text(d => d.name.length > 20 ? d.name.slice(0, 18) + '...' : d.name)
      .attr('dy', d => sizeScale(d.paper_count) + 14)
      .attr('text-anchor', 'middle')
      .style('fill', 'currentColor')
      .style('font-size', '10px')
      .style('font-family', 'monospace')
      .style('pointer-events', 'none');

    // Simulation tick
    simulation.on('tick', () => {
      linkElements
        .attr('x1', (d: any) => d.source.x)
        .attr('y1', (d: any) => d.source.y)
        .attr('x2', (d: any) => d.target.x)
        .attr('y2', (d: any) => d.target.y);

      nodeElements
        .attr('transform', (d: any) => `translate(${d.x},${d.y})`);
    });

    return () => { simulation.stop(); };
  }, [nodes, edges]);

  if (loading) {
    return (
      <div className="w-full h-full flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-accent-teal" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="w-full h-full flex flex-col items-center justify-center gap-3">
        <AlertCircle className="w-8 h-8 text-accent-amber" />
        <p className="font-mono text-xs text-muted uppercase tracking-wider">
          Build citation network first
        </p>
        <p className="text-sm text-muted text-center max-w-md">
          Switch to the Citations tab and click "Build Citation Network" to
          generate the data needed for concept flow analysis.
        </p>
      </div>
    );
  }

  if (!nodes.length) {
    return (
      <div className="w-full h-full flex flex-col items-center justify-center gap-3">
        <Workflow className="w-8 h-8 text-muted" />
        <p className="font-mono text-xs text-muted">No concept flows detected</p>
      </div>
    );
  }

  return (
    <div ref={containerRef} className="w-full h-full relative">
      {/* Stats */}
      <div className="absolute top-2 left-4 z-10 flex items-center gap-4">
        {stats && (
          <>
            <span className="font-mono text-xs text-accent-teal">
              {stats.concepts} concepts
            </span>
            <span className="font-mono text-xs text-muted">
              {stats.flows} knowledge flows
            </span>
          </>
        )}
      </div>

      {/* Legend */}
      <div className="absolute top-2 right-4 z-10 flex items-center gap-4">
        <div className="flex items-center gap-1">
          <div className="w-3 h-3 rounded-full bg-[#2EC4B6]" />
          <span className="font-mono text-xs text-muted">Source</span>
        </div>
        <div className="flex items-center gap-1">
          <div className="w-3 h-3 rounded-full bg-[#F4A261]" />
          <span className="font-mono text-xs text-muted">Target</span>
        </div>
        <div className="flex items-center gap-1">
          <div className="w-3 h-3 rounded-full bg-[#9D4EDD]" />
          <span className="font-mono text-xs text-muted">Both</span>
        </div>
        <div className="flex items-center gap-1">
          <div className="w-6 h-0.5 bg-[#457B9D]" />
          <span className="font-mono text-xs text-muted">→ Flow</span>
        </div>
      </div>

      {/* Edge Tooltip */}
      {hoveredEdge && (
        <div className="absolute bottom-16 left-1/2 -translate-x-1/2 z-20
          bg-paper dark:bg-ink border border-ink/10 dark:border-paper/10
          p-3 shadow-lg font-mono text-xs max-w-sm">
          <p className="text-accent-teal mb-1">
            {hoveredEdge.source_concept_name} → {hoveredEdge.target_concept_name}
          </p>
          <p className="text-ink dark:text-paper">
            {hoveredEdge.weight} citation{hoveredEdge.weight > 1 ? 's' : ''} support this flow
          </p>
          {hoveredEdge.example_papers.length > 0 && (
            <div className="mt-2 border-t border-ink/10 dark:border-paper/10 pt-2">
              <p className="text-muted mb-1">Example papers:</p>
              {hoveredEdge.example_papers.map((p, i) => (
                <p key={i} className="text-ink dark:text-paper truncate">{p}</p>
              ))}
            </div>
          )}
        </div>
      )}

      {/* D3 Chart */}
      <svg ref={svgRef} className="w-full h-full" />
    </div>
  );
}
```

### Frontend: Integration

#### `types/graph.ts` — Extend ViewMode

```typescript
// Change:
export type ViewMode = '3d' | 'topic' | 'gaps' | 'temporal' | 'citations';
// To:
export type ViewMode = '3d' | 'topic' | 'gaps' | 'temporal' | 'citations' | 'flow';
```

#### `KnowledgeGraph3D.tsx` — 6th tab

Add import:
```typescript
import { ConceptFlowView } from './ConceptFlowView';
```

Add view rendering:
```tsx
{viewMode === 'flow' && (
  <ConceptFlowView projectId={projectId} />
)}
```

Add tab button (after Citations tab):
```tsx
<button
  onClick={() => setViewMode('flow')}
  className={`flex items-center gap-1.5 px-3 py-1.5 rounded text-sm font-medium transition-all ${
    viewMode === 'flow'
      ? 'bg-[#9D4EDD] text-white shadow-sm'
      : 'text-muted hover:text-ink dark:hover:text-paper hover:bg-surface/10'
  }`}
  title="개념 인용 흐름 (Concept Flow)"
>
  <Workflow className="w-4 h-4" />
  Flow
</button>
```

> **Note**: Add `Workflow` to lucide-react imports.

#### `api.ts` — New method

Add after `getCitationNetwork()`:

```typescript
// Concept Citation Flow
async getConceptFlow(projectId: string, minWeight: number = 1): Promise<{
  nodes: Array<{
    id: string;
    name: string;
    paper_count: number;
    is_source: boolean;
    is_target: boolean;
  }>;
  edges: Array<{
    source_concept_id: string;
    source_concept_name: string;
    target_concept_id: string;
    target_concept_name: string;
    weight: number;
    example_papers: string[];
  }>;
  total_flows: number;
  unique_concepts: number;
}> {
  const params = new URLSearchParams({ min_weight: minWeight.toString() });
  return this.request(`/api/graph/citation/${projectId}/concept-flow?${params}`);
}
```

---

## Commit Strategy

| Order | Message | Files |
|-------|---------|-------|
| 1 | `feat(citation): concept-level knowledge flow computation` | `citation_builder.py`, `graph.py` |
| 2 | `feat(citation): concept flow force-directed visualization` | `ConceptFlowView.tsx`, `KnowledgeGraph3D.tsx`, `api.ts`, `types/graph.ts` |
| 3 | `docs(v0.13.1): release notes and SDD updates` | `RELEASE_NOTES_v0.13.1.md`, `DOCS/` |

---

## Acceptance Criteria

| # | Criterion | Verification |
|---|-----------|-------------|
| 1 | **Response time**: Concept flow computation < 5 seconds (from cached citation data) | `time curl .../api/graph/citation/{pid}/concept-flow` |
| 2 | **Fallback**: No citation data → "Build citation network first" guide message | Request flow before building citation network |
| 3 | **UI**: Force-directed graph with concept nodes (colored by role), directed edges with arrows, hover tooltip showing flow weight and example papers | Visual check in browser |

---

## Technical Risks & Mitigations

| Risk | Probability | Mitigation |
|------|-------------|-----------|
| Citation network not cached (server restart) | Medium | Clear error message directing user to build citation network; sub-2min rebuild |
| Combinatorial explosion (many concepts × many papers) | Medium | `max_concepts=30` default; `min_weight=1` filter; top-N sorting |
| D3 force simulation performance with 50+ nodes | Low | Collision force prevents overlap; simulation auto-cools; zoom for navigation |
| Concept names too long for labels | Low | Truncate to 20 chars with ellipsis; full name in hover tooltip |
| Self-loop edges (paper cites itself) | Low | Filtered out in `compute_concept_flow` with `cited_cid == citing_cid` check |
| Tab overflow with 6 tabs | Medium | Consider grouping Citations + Flow under a single "Citations" tab with sub-toggle |

---

## DB Persistence Decision (Deferred)

At this point, evaluate whether to persist citation data to DB:

| Factor | In-Memory (Current) | DB Persistence |
|--------|---------------------|----------------|
| Build time | User waits <2min | One-time, then instant |
| Server restart | Rebuild needed | Data survives |
| Disk usage | ~0 | ~100KB per project |
| Complexity | Low | Medium (migration needed) |
| Staleness | Fresh on each build | May become stale |

**Recommendation**: Keep in-memory for v0.13.1. If users build citation networks frequently and server restarts are common, add DB persistence in a v0.14.0 patch with a simple `citation_cache` table.

---

## Portfolio Demo Extension (v0.13.1)

Building on the v0.12.0 demo flow:

```
7. Citations 탭으로 전환 → "Build Citation Network" 클릭  ← v0.13.0
   → "34편 중 28편이 Semantic Scholar에서 매칭되었습니다"
   → Litmaps 스타일 scatter plot에서 인용 관계 탐색

8. Flow 탭으로 전환 → 개념 간 지식 흐름 시각화  ← v0.13.1
   → "AI Trust는 인용을 통해 Algorithmic Fairness에 영향을 미쳤습니다"
   → "이 도구만이 논문 인용을 넘어 개념 수준의 지식 전파를 보여줍니다"
   → 논문 간 인용이 아닌, 개념 간 영향력을 시각화하는 것은
     ScholaRAG Graph만의 독창적 기능입니다
```
