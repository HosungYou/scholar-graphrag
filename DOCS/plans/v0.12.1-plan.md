# v0.12.1 Release Plan — Temporal View (Time-Axis Visualization)

> **Version**: 0.12.1
> **Base**: v0.12.0
> **Difficulty**: Medium-High
> **Estimated Commits**: 2-3
> **Prerequisite**: v0.12.0 completed

---

## Objective

Add a **4th view tab "Temporal"** to KnowledgeGraph3D that visualizes concept emergence over time — showing how the knowledge landscape evolved year by year as papers were published.

This answers the question: *"When did each research topic first appear, and how has the field evolved?"*

---

## Scope

- D3.js-based timeline chart (bar chart + concept bubbles per year)
- New `GET /api/graph/temporal/{project_id}/timeline` endpoint returning aggregated year data
- 4th tab in KnowledgeGraph3D view switcher
- Leverages existing `source_year`, `first_seen_year`, `last_seen_year` columns (migration 013)
- Leverages existing `GET /api/graph/temporal/{project_id}` endpoint (stats + filtered data)

---

## Reused Code

| Source | What | Location |
|--------|------|----------|
| DB columns | `entities.source_year`, `first_seen_year`, `last_seen_year` | migration `013_entity_temporal.sql` |
| API endpoint | `GET /api/graph/temporal/{project_id}` — returns temporal stats + filtered graph | `graph.py:2387` |
| API endpoint | `POST /api/graph/temporal/{project_id}/migrate` — backfills temporal data | `graph.py:2565` |
| DB function | `migrate_entity_temporal_data()` — populates temporal columns from paper metadata | `013_entity_temporal.sql:48` |
| DB function | `get_project_temporal_stats()` — min/max year, counts | `013_entity_temporal.sql:136` |
| Frontend | `api.getTemporalGraph()` — already in `api.ts:626` | `api.ts` |
| Frontend | `TemporalSlider.tsx` — existing slider component (can reference for interaction pattern) | `frontend/components/graph/` |
| Type | `ViewMode = '3d' \| 'topic' \| 'gaps'` — extend to include `'temporal'` | `frontend/types/graph.ts:331` |

---

## Changed Files

| File | Change |
|------|--------|
| `backend/routers/graph.py` | Add `GET /api/graph/temporal/{project_id}/timeline` endpoint |
| `frontend/components/graph/TemporalView.tsx` | **New** — D3.js timeline visualization |
| `frontend/components/graph/KnowledgeGraph3D.tsx` | Add 4th "Temporal" view tab |
| `frontend/lib/api.ts` | Add `getTemporalTimeline()` method |
| `frontend/types/graph.ts` | Extend `ViewMode` type to include `'temporal'` |

---

## Implementation Detail

### Backend: Timeline Aggregation Endpoint

#### `graph.py` — `GET /api/graph/temporal/{project_id}/timeline`

This endpoint differs from the existing `/temporal/{project_id}` (which returns full graph data) by returning **aggregated per-year statistics** optimized for the timeline chart.

Insert after the existing `migrate_temporal_data` endpoint (line ~2603):

```python
class YearBucket(BaseModel):
    """Aggregated data for a single year."""
    year: int
    new_concepts: int  # Concepts first seen this year
    total_concepts: int  # Cumulative concepts up to this year
    top_concepts: List[str]  # Top 5 concept names for this year


class TemporalTimelineResponse(BaseModel):
    """Timeline data for temporal visualization."""
    min_year: int
    max_year: int
    buckets: List[YearBucket]
    total_with_year: int
    total_without_year: int


@router.get("/temporal/{project_id}/timeline", response_model=TemporalTimelineResponse)
async def get_temporal_timeline(
    project_id: UUID,
    database=Depends(get_db),
    current_user: Optional[User] = Depends(require_auth_if_configured),
):
    """Get aggregated timeline data for temporal visualization.

    Returns per-year buckets with concept counts and top concepts,
    optimized for rendering a timeline chart.
    """
    await verify_project_access(database, project_id, current_user, "access")

    try:
        # Get per-year concept counts and names
        year_rows = await database.fetch(
            """
            SELECT
                first_seen_year as year,
                COUNT(*) as concept_count,
                ARRAY_AGG(name ORDER BY
                    (properties->>'centrality_pagerank')::float DESC NULLS LAST
                    LIMIT 5
                ) as top_names
            FROM entities
            WHERE project_id = $1
              AND entity_type IN ('Concept', 'Method', 'Finding', 'Problem',
                                  'Dataset', 'Metric', 'Innovation', 'Limitation')
              AND first_seen_year IS NOT NULL
            GROUP BY first_seen_year
            ORDER BY first_seen_year
            """,
            str(project_id),
        )

        if not year_rows:
            # Try source_year as fallback
            year_rows = await database.fetch(
                """
                SELECT
                    source_year as year,
                    COUNT(*) as concept_count,
                    ARRAY_AGG(name ORDER BY name LIMIT 5) as top_names
                FROM entities
                WHERE project_id = $1
                  AND entity_type IN ('Concept', 'Method', 'Finding', 'Problem',
                                      'Dataset', 'Metric', 'Innovation', 'Limitation')
                  AND source_year IS NOT NULL
                GROUP BY source_year
                ORDER BY source_year
                """,
                str(project_id),
            )

        # Count entities without temporal data
        total_without = await database.fetchval(
            """
            SELECT COUNT(*) FROM entities
            WHERE project_id = $1
              AND entity_type IN ('Concept', 'Method', 'Finding', 'Problem',
                                  'Dataset', 'Metric', 'Innovation', 'Limitation')
              AND first_seen_year IS NULL AND source_year IS NULL
            """,
            str(project_id),
        )

        if not year_rows:
            return TemporalTimelineResponse(
                min_year=2000, max_year=2025,
                buckets=[], total_with_year=0,
                total_without_year=total_without or 0,
            )

        # Build cumulative buckets
        buckets = []
        cumulative = 0
        for row in year_rows:
            cumulative += row["concept_count"]
            buckets.append(YearBucket(
                year=row["year"],
                new_concepts=row["concept_count"],
                total_concepts=cumulative,
                top_concepts=(row["top_names"] or [])[:5],
            ))

        return TemporalTimelineResponse(
            min_year=year_rows[0]["year"],
            max_year=year_rows[-1]["year"],
            buckets=buckets,
            total_with_year=cumulative,
            total_without_year=total_without or 0,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get temporal timeline: {e}")
        raise HTTPException(500, "Failed to get temporal timeline data")
```

> **Note on ARRAY_AGG LIMIT**: PostgreSQL doesn't support `LIMIT` inside `ARRAY_AGG` directly. The actual implementation should use a subquery or `(ARRAY_AGG(name ORDER BY ...))[1:5]` slice syntax instead:
> ```sql
> (ARRAY_AGG(name ORDER BY (properties->>'centrality_pagerank')::float DESC NULLS LAST))[1:5] as top_names
> ```

### Frontend: Temporal View Component

#### `TemporalView.tsx` — New component

```tsx
'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import { Loader2, Calendar, AlertCircle } from 'lucide-react';
import * as d3 from 'd3';
import { api } from '@/lib/api';

interface YearBucket {
  year: number;
  new_concepts: number;
  total_concepts: number;
  top_concepts: string[];
}

interface TemporalViewProps {
  projectId: string;
}

export function TemporalView({ projectId }: TemporalViewProps) {
  const svgRef = useRef<SVGSVGElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [data, setData] = useState<{
    buckets: YearBucket[];
    min_year: number;
    max_year: number;
    total_with_year: number;
    total_without_year: number;
  } | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hoveredYear, setHoveredYear] = useState<number | null>(null);

  // Fetch timeline data
  useEffect(() => {
    let cancelled = false;
    setLoading(true);
    setError(null);

    api.getTemporalTimeline(projectId)
      .then(result => {
        if (!cancelled) setData(result);
      })
      .catch(err => {
        if (!cancelled) setError(err.message || 'Failed to load temporal data');
      })
      .finally(() => {
        if (!cancelled) setLoading(false);
      });

    return () => { cancelled = true; };
  }, [projectId]);

  // D3 rendering
  useEffect(() => {
    if (!data || !data.buckets.length || !svgRef.current || !containerRef.current) return;

    const container = containerRef.current;
    const width = container.clientWidth;
    const height = container.clientHeight - 40; // Leave room for header
    const margin = { top: 20, right: 30, bottom: 50, left: 60 };
    const innerW = width - margin.left - margin.right;
    const innerH = height - margin.top - margin.bottom;

    const svg = d3.select(svgRef.current);
    svg.selectAll('*').remove();
    svg.attr('width', width).attr('height', height);

    const g = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

    // Scales
    const x = d3.scaleBand()
      .domain(data.buckets.map(b => String(b.year)))
      .range([0, innerW])
      .padding(0.2);

    const y = d3.scaleLinear()
      .domain([0, d3.max(data.buckets, b => b.new_concepts) || 1])
      .nice()
      .range([innerH, 0]);

    // Axes
    g.append('g')
      .attr('transform', `translate(0,${innerH})`)
      .call(d3.axisBottom(x).tickValues(
        data.buckets.filter((_, i) => i % Math.ceil(data.buckets.length / 10) === 0)
          .map(b => String(b.year))
      ))
      .selectAll('text')
      .attr('transform', 'rotate(-45)')
      .style('text-anchor', 'end')
      .style('fill', 'currentColor')
      .style('font-size', '11px');

    g.append('g')
      .call(d3.axisLeft(y).ticks(5))
      .selectAll('text')
      .style('fill', 'currentColor')
      .style('font-size', '11px');

    // Y-axis label
    g.append('text')
      .attr('transform', 'rotate(-90)')
      .attr('y', -45).attr('x', -innerH / 2)
      .attr('text-anchor', 'middle')
      .style('fill', 'currentColor')
      .style('font-size', '12px')
      .text('New Concepts');

    // Bars
    g.selectAll('.bar')
      .data(data.buckets)
      .join('rect')
      .attr('class', 'bar')
      .attr('x', d => x(String(d.year)) || 0)
      .attr('y', d => y(d.new_concepts))
      .attr('width', x.bandwidth())
      .attr('height', d => innerH - y(d.new_concepts))
      .attr('fill', '#2EC4B6')
      .attr('opacity', 0.8)
      .attr('rx', 2)
      .on('mouseenter', function(event, d) {
        d3.select(this).attr('opacity', 1).attr('fill', '#45B7D1');
        setHoveredYear(d.year);
      })
      .on('mouseleave', function() {
        d3.select(this).attr('opacity', 0.8).attr('fill', '#2EC4B6');
        setHoveredYear(null);
      });

    // Cumulative line (secondary y-axis)
    const y2 = d3.scaleLinear()
      .domain([0, d3.max(data.buckets, b => b.total_concepts) || 1])
      .range([innerH, 0]);

    const line = d3.line<YearBucket>()
      .x(d => (x(String(d.year)) || 0) + x.bandwidth() / 2)
      .y(d => y2(d.total_concepts))
      .curve(d3.curveMonotoneX);

    g.append('path')
      .datum(data.buckets)
      .attr('fill', 'none')
      .attr('stroke', '#F4A261')
      .attr('stroke-width', 2)
      .attr('d', line);

    // Right y-axis for cumulative
    g.append('g')
      .attr('transform', `translate(${innerW},0)`)
      .call(d3.axisRight(y2).ticks(5))
      .selectAll('text')
      .style('fill', '#F4A261')
      .style('font-size', '11px');

  }, [data]);

  // Find hovered bucket
  const hoveredBucket = data?.buckets.find(b => b.year === hoveredYear);

  if (loading) {
    return (
      <div className="w-full h-full flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-accent-teal" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="w-full h-full flex flex-col items-center justify-center gap-3">
        <AlertCircle className="w-8 h-8 text-accent-red" />
        <p className="text-sm text-muted">{error}</p>
      </div>
    );
  }

  if (!data || !data.buckets.length) {
    return (
      <div className="w-full h-full flex flex-col items-center justify-center gap-3">
        <Calendar className="w-8 h-8 text-muted" />
        <p className="font-mono text-xs text-muted uppercase tracking-wider">
          No temporal data available
        </p>
        <p className="text-sm text-muted">
          Import papers with publication years to see the timeline.
        </p>
      </div>
    );
  }

  return (
    <div ref={containerRef} className="w-full h-full relative">
      {/* Header Stats */}
      <div className="absolute top-2 left-4 z-10 flex items-center gap-4">
        <span className="font-mono text-xs text-muted">
          {data.min_year}–{data.max_year}
        </span>
        <span className="font-mono text-xs text-accent-teal">
          {data.total_with_year} concepts with year data
        </span>
        {data.total_without_year > 0 && (
          <span className="font-mono text-xs text-muted">
            ({data.total_without_year} undated)
          </span>
        )}
      </div>

      {/* Legend */}
      <div className="absolute top-2 right-4 z-10 flex items-center gap-4">
        <div className="flex items-center gap-1">
          <div className="w-3 h-3 bg-[#2EC4B6] rounded-sm" />
          <span className="font-mono text-xs text-muted">New / year</span>
        </div>
        <div className="flex items-center gap-1">
          <div className="w-3 h-0.5 bg-[#F4A261]" />
          <span className="font-mono text-xs text-muted">Cumulative</span>
        </div>
      </div>

      {/* Tooltip */}
      {hoveredBucket && (
        <div className="absolute bottom-16 left-1/2 -translate-x-1/2 z-20
          bg-paper dark:bg-ink border border-ink/10 dark:border-paper/10
          p-3 shadow-lg font-mono text-xs min-w-[200px]">
          <p className="text-accent-teal font-bold mb-1">{hoveredBucket.year}</p>
          <p className="text-ink dark:text-paper">
            +{hoveredBucket.new_concepts} new concepts
          </p>
          <p className="text-muted">
            {hoveredBucket.total_concepts} total cumulative
          </p>
          {hoveredBucket.top_concepts.length > 0 && (
            <div className="mt-2 border-t border-ink/10 dark:border-paper/10 pt-2">
              <p className="text-muted mb-1">Top concepts:</p>
              {hoveredBucket.top_concepts.map((c, i) => (
                <p key={i} className="text-ink dark:text-paper truncate">{c}</p>
              ))}
            </div>
          )}
        </div>
      )}

      {/* D3 Chart */}
      <svg ref={svgRef} className="w-full h-full" />
    </div>
  );
}
```

### Frontend: View Tab Integration

#### `types/graph.ts` — Extend ViewMode

```typescript
// Line 331: Change from
export type ViewMode = '3d' | 'topic' | 'gaps';
// To
export type ViewMode = '3d' | 'topic' | 'gaps' | 'temporal';
```

#### `KnowledgeGraph3D.tsx` — Add 4th tab

Add import:
```typescript
import { TemporalView } from './TemporalView';
```

Add view rendering (after `{viewMode === 'gaps' && ...}` block):
```tsx
{viewMode === 'temporal' && (
  <TemporalView projectId={projectId} />
)}
```

Add tab button (after the Gaps tab button):
```tsx
<button
  onClick={() => setViewMode('temporal')}
  className={`flex items-center gap-1.5 px-3 py-1.5 rounded text-sm font-medium transition-all ${
    viewMode === 'temporal'
      ? 'bg-accent-teal text-white shadow-sm'
      : 'text-muted hover:text-ink dark:hover:text-paper hover:bg-surface/10'
  }`}
  title="시간축 시각화 (Temporal)"
>
  <Calendar className="w-4 h-4" />
  Temporal
</button>
```

> **Note**: Add `Calendar` to the lucide-react imports.

#### `api.ts` — Timeline method

Add after `getTemporalGraph()` (line ~637):

```typescript
// Temporal Timeline (aggregated)
async getTemporalTimeline(projectId: string): Promise<{
  min_year: number;
  max_year: number;
  buckets: Array<{
    year: number;
    new_concepts: number;
    total_concepts: number;
    top_concepts: string[];
  }>;
  total_with_year: number;
  total_without_year: number;
}> {
  return this.request(`/api/graph/temporal/${projectId}/timeline`);
}
```

---

## Commit Strategy

| Order | Message | Files |
|-------|---------|-------|
| 1 | `feat(temporal): timeline aggregation API endpoint` | `graph.py` |
| 2 | `feat(temporal): D3 timeline view with year buckets and cumulative line` | `TemporalView.tsx`, `KnowledgeGraph3D.tsx`, `api.ts`, `types/graph.ts` |
| 3 | `docs(v0.12.1): release notes and SDD updates` | `RELEASE_NOTES_v0.12.1.md`, `DOCS/` |

---

## Acceptance Criteria

| # | Criterion | Verification |
|---|-----------|-------------|
| 1 | **Response time**: Timeline API < 2 seconds | `time curl .../api/graph/temporal/{pid}/timeline` |
| 2 | **Fallback**: No temporal data → "No temporal data available" message | Test with project that has no `first_seen_year` |
| 3 | **UI**: Temporal tab → bar chart (new/year) + cumulative line + hover tooltip with top concepts | Visual check; hover bars to see concept names |

---

## Technical Risks & Mitigations

| Risk | Probability | Mitigation |
|------|-------------|-----------|
| Most entities lack `first_seen_year` | Medium | Fallback to `source_year`; show "X undated" count; suggest running `/migrate` |
| D3 rendering performance with many years | Low | Band scale handles sparse years well; max ~50 bars typical |
| `ARRAY_AGG` with `LIMIT` PostgreSQL syntax | Medium | Use array slice `[1:5]` instead of inline LIMIT |
| SVG resize on container change | Low | Use `containerRef` dimensions; D3 re-renders on data change |
| Tab overflow with 4 tabs on mobile | Low | Existing tab bar uses flex-wrap; 4 tabs still fit at 360px+ |

---

## Dependencies on v0.12.0

- No direct code dependencies — Temporal View reads from existing `entities` table
- v0.12.0 is prerequisite only for release ordering (features are independent)
- Can be developed in parallel on a separate branch if needed
